osi 七层模型的理解

# osi 七层模型 

Open System Interconnection/Reference mode
开放系统互联参考模型

七层模型自下而上分别为：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。其中低四层完成数据传输，高三层面向用户。

## 物理包括哪些呢？

## 数据链路呢？

## 网络层呢？


## 传输层呢？


## 会话层、 表示层、 应用层都是啥？




## 上层调用下层， 各层之间 都封装的很好
https://www.zhihu.com/question/24002080/answer/150902711


每一次接受下层的服务，并且为上一次提供特定的服务。

上下层交互时所遵守的约定叫做：接口。

同层之间交互时所遵守的约定叫做：协议。



# TCP/IP协议簇
- 常被视为是简化的七层OSI模型。
https://blog.minhow.com/2017/01/07/protocol/tcp-osi/

想知道协议是干嘛的， 从协议维护的啥出发，

你是谁， 你要干嘛， 你怎么实现？
你是谁由 ip和port维护
你要干嘛由  会话协议维护
怎么实现？ 由底层的网络维护。
你可以用啥把这些底层的网络维护都给封装了， 然后直接把这个作为一个工具， 用来进行端到端通信。
socket实现了对底层网络的维护， 不过socket需要进行配置， 配置参数包括 自己的ip和port, 对方ip和port, 以及选择何种通讯协议 tcp或者是udp


他是谁， 他在哪， 他咋理解你的消息？
socket实现了对底层网络维护的封装， 开着socket就可以与外界交互了， 
当socket收到外界通信请求时， 他就收到了消息



http/https也是一个对底层网络维护的封装， 默认参数配置是 tcp协议， 



TCP/IP提供点对点的链接机制，将数据应该如何封装、定址、传输、路由以及在目的地如何接收，都加以标准化。
它将软件通信过程抽象化为四个抽象层，采取协议堆栈的方式，分别实现出不同通信协议。
协议族下的各种协议，依其功能不同，被分别归属到这四个层次结构之中[7][8]，常被视为是简化的七层OSI模型。



每一个应用层（TCP/IP参考模型的最高层）协议一般都会使用到两个传输层协议之一： 面向连接的TCP传输控制协议和无连接的包传输的UDP用户数据报文协议。 常用的应用层协议有：

运行在TCP协议上的协议：
HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。
HTTPS（Hypertext Transfer Protocol over Secure Socket Layer, or HTTP over SSL，安全超文本传输协议）,HTTP协议的安全版本。
FTP（File Transfer Protocol，文件传输协议），由名知义，用于文件传输。
POP3（Post Office Protocol, version 3，邮局协议），收邮件用。
SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。
TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。
SSH（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。

运行在UDP协议上的协议：
BOOTP（Boot Protocol，启动协议），应用于无盘设备。
NTP（Network Time Protocol，网络时间协议），用于网络同步。
DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。
其他：
DNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作（运行在TCP和UDP协议上）。
ECHO（Echo Protocol，回绕协议），用于查错及测量应答时间（运行在TCP和UDP协议上）。
SNMP（Simple Network Management Protocol，简单网络管理协议），用于网络信息的收集和网络管理。
ARP（Address Resolution Protocol，地址解析协议），用于动态解析以太网硬件的地址。



可以看到基于 以tcp为基础通讯协议， 然后对底层网络维护的封装的有 http, https, ftp 等

而基于 以udp为基础通讯协议， 然后对底层网络维护的封装的后 bootp, ntp, dhcp等


同时呢， 利用socket可以实现对 底层网络维护的封装的定制化， 比如可选 tcp或 udp做为通信协议。


明白了吧， tcp 和 udp 是做为基石协议存在的， 而具体的应用是要用 socket, http/https, ftp 等封装好的工具， 实现网络通信的。



## 研究下tcp
https://zh.wikipedia.org/wiki/传输控制协议

传输控制协议（英语：Transmission Control Protocol，缩写为 TCP）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，用户数据包协议（UDP）是同一层内另一个重要的传输协议。

在因特网协议族（Internet protocol suite）中，TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。


应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（MTU）的限制）。之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。


TCP协议的运行可划分为三个阶段：连接创建(connection establishment)、数据传送（data transfer）和连接终止（connection termination）。

创建通路
TCP用三路握手（或称三次握手，three-way handshake）过程创建一个连接。在连接创建过程中，很多参数要被初始化，例如序号被初始化以保证按序传输和连接的强壮性。


TCP连接的正常创建
一对终端同时初始化一个它们之间的连接是可能的。但通常是由一端打开一个套接字（socket）然后监听来自另一方的连接，这就是通常所指的被动打开（passive open）。服务器端被被动打开以后，用户端就能开始创建主动打开（active open）。

客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三路握手的一部分。客户端把这段连接的序号设定为随机数A。
服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK的确认码应为A+1，SYN/ACK包本身又有一个随机产生的序号B。
最后，客户端再发送一个ACK。当服务端收到这个ACK的时候，就完成了三路握手，并进入了连接创建状态。此时包的序号被设定为收到的确认号A+1，而响应号则为B+1。
如果服务器端接到了客户端发的SYN后回了SYN-ACK后客户端掉线了，服务器端没有收到客户端回来的ACK，那么，这个连接处于一个中间状态，即没成功，也没失败。于是，服务器端如果在一定时间内没有收到的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s才知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s，TCP才会断开这个连接。使用三个TCP参数来调整行为：tcp_synack_retries 减少重试次数；tcp_max_syn_backlog，增大SYN连接数；tcp_abort_on_overflow决定超出能力时的行为



断开连接 要4次挥手
client -> server: fin
server - > client : ack
server -> client: fin 
cliet - > server : ack 



## 研究下udp 

目前接触到的都是 用http进行通讯

基于udp的网络工具还不会用啊
也不知道udp该咋弄

udp有client和server吗？

有像http的响应吗？

## 数据大小限制
http://docs.52im.net/extend/docs/book/tcpip/vol1/11/

理论上，IP数据报的最大长度是65535字节，这是由IP首部（图3-1）16比特总长度字段所限制的。去除20字节的IP首部和8个字节的UDP首部，UDP数据报中用户数据的最长长度为65507字节。但是，大多数实现所提供的长度比这个最大值小。

http://www.52im.net/topic-tcpipvol1.html

IP分片
分片可以发生在原始发送端主机上，也可以发生在中间路由器上。

正如我们在2.8节描述的那样，物理网络层一般要限制每次发送数据帧的最大长度。任何时候IP层接收到一份要发送的IP数据报时，它要判断向本地哪个接口发送数据（选路），并查询该接口获得其MTU。IP把MTU与数据报长度进行比较，如果需要则进行分片。分片可以发生在原始发送端主机上，也可以发生在中间路由器上。

把一份IP数据报分片以后，只有到达目的地才进行重新组装（这里的重新组装与其他网络协议不同，它们要求在下一站就进行进行重新组装，而不是在最终的目的地）。重新组装由目的端的IP层来完成，其目的是使分片和重新组装过程对运输层（TCP和UDP）是透明的，除了某些可能的越级操作外。已经分片过的数据报有可能会再次进行分片（可能不止一次）。IP首部中包含的数据为分片和重新组装提供了足够的信息。

另外需要解释几个术语：IP数据报是指IP层端到端的传输单元（在分片之前和重新组装之后），分组是指在IP层和链路层之间传送的数据单元。一个分组可以是一个完整的IP数据报，也可以是IP数据报的一个分片。


11.10 最大UDP数据报长度
理论上，IP数据报的最大长度是65535字节，这是由IP首部（图3-1）16比特总长度字段所限制的。去除20字节的IP首部和8个字节的UDP首部，UDP数据报中用户数据的最长长度为65507字节。但是，大多数实现所提供的长度比这个最大值小。

我们将遇到两个限制因素。第一，应用程序可能会受到其程序接口的限制。socket API提供了一个可供应用程序调用的函数，以设置接收和发送缓存的长度。对于UDP socket，这个长度与应用程序可以读写的最大UDP数据报的长度直接相关。现在的大部分系统都默认提供了可读写大于8192字节的UDP数据报（使用这个默认值是因为8192是NFS读写用户数据数的默认值）。




维护监听，跑个服务一直处于监听状态， 实现实时接收数据

基于udp协议的socket通信
https://blog.csdn.net/coder_pig/article/details/48544085


基于udp的im
https://www.jerrylou.me/im/im-system-architecture-20170628.html
https://github.com/JackJiang2011/MobileIMSDK


深入理解udp
https://juejin.im/entry/59afe01d6fb9a02478050a60












# socket实现了对底层网络的维护
https://blog.csdn.net/u011240877/article/details/72860483

TCP 或者 UDP 的报文中，除了数据本身还包含了包的信息，比如目的地址和端口，包的源地址和端口，以及其他附加校验信息。

由于包的长度有限，在传输的过程中还需要拆包，到达目的地后再重新组合。

如果有丢失或者损坏的包还需要重传，有的在到达目的地后还需要重新排序。

这些工作是复杂且与业务无关的，Socket 为我们封装了这些处理工作。

Socket 被称为“套接字”，它把复杂的 TCP/IP 协议簇隐藏在背后，为用户提供简单的客户端到服务端接口，让我们感觉这边输入数据，那边就直接收到了数据，像一个“管道”一样。












